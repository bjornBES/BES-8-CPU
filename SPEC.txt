OVERVIEW
 16 bit data width
 20 bit addr width ~ 131 kilobytes
 Memory banking via the MB register allowing for 65535 possible memory banks
INSTRUCTIONS
 00 MOV     reg16/reg32,    reg/imm/addr    -> reg16 = reg16/imm/mem[addr] | reg32 = imm32/reg32
 01 STR     reg16/reg32,    addr            -> mem[addr] = reg16 | mem[addr] = reg32[H] mem[addr + 1] = reg32[L]
 02 LOR     reg16/reg32,    addr            -> reg16 = mem[addr] | reg[32] = mem[addr] + mem[addr + 1]
 03 PUSH    reg16/imm16                     -> mem[SP] = reg16/imm16 SP--
 04 POP     reg16/addr                      -> SP++ reg16/addr = mem[SP]
 05 ADD     reg16,          reg16/imm       -> reg16 = reg16 + reg16/imm16 + C
 06 STI     imm16,          addr            -> mem[addr] = imm16
 07 SUB     reg16,          reg16/imm       -> reg16 = reg16 - reg16/imm16 - C
 08 AND     reg16,          reg16/imm       -> reg16 = reg16 & reg16/imm16
 09 OR      reg16,          reg16/imm       -> reg16 = reg16 | reg16/imm16
 0A NOR     reg16,          reg16/imm       -> reg16 = !(reg16 | reg16/imm16)
 0B CMP     reg16,          reg16/imm       -> F = reg16 - imm/reg16
 0C JNE     addr                            -> PC = addr if E == 0
 0D INT                                     -> system call 
 0E JMP     addr                            -> PC = addr
 0F JME     addr                            -> PC = addr if E == 1
 10 HALT    imm16/null                      -> DIS
 11 CALL    addr                            -> push PC, PC = addr
 12 RTS                                     -> pop PC
 13 INC     reg16/addr                      -> reg16/mem[addr]++
 14 DEC     reg16/addr                      -> reg16/mem[addr]--
 15 OUTB    imm16/reg16       reg16/imm16   -> port[imm16/reg16] = reg16/imm16
 16 INB     imm16/reg16       reg16         -> reg = port[imm16/reg16]
 17 NOP                                     -> 
 18 SEF     imm16                           -> F[imm16] = 1
 19 CLF     imm16                           -> F[imm16] = 0
 1A JMZ     addr                            -> PC = addr if Z == 1
 1B JNZ     addr                            -> PC = addr if Z == 0
 1C JML     addr                            -> PC = addr if L == 1
 1D JMG     addr                            -> PC = addr if L == 0
 1E JMC     addr                            -> PC = addr if C == 1
 1F JNC     addr                            -> PC = addr if C == 0
 20 MUL     reg16,          reg16/imm16     -> reg16 = reg16 * reg16/imm16
 21 DIV     reg16,          reg16/imm16     -> reg16 = reg16 / reg16/imm16
 22 NOT     reg16                           -> reg16 = !reg16 
 23 ADDL    reg32,          reg32/imm32     -> reg32 = reg32 + reg32/imm32 + C
 24 SUBL    reg32           reg32/imm32     -> reg32 = reg32 - reg32/imm32 - C
 25 ANDL    reg32           reg32/imm32     -> reg32 = reg32 & reg32/imm32 
 26 ORL     reg32           reg32/imm32     -> reg32 = reg32 | reg32/imm32
 27 NORL    reg32           reg32/imm32     -> reg32 = !(reg32 | reg32/imm32)
 28 NOTL    reg32                           -> reg32 = !reg32
 29 JMPL    reg32/addr                      -> PC = reg32/addr
 30 PUSHL   imm32/reg32                     -> mem[SP] = reg32[H]/imm32[H] SP-- mem[SP] = reg32[L]/imm32[L] SP--
 30 POPL    reg32                           -> SP++ reg32 = mem[SP] + mem[SP + 1] SP++

REGISTERS
AX  (0b00_0000)   GP 16 bit register
AL  (0b10_0000)   GP 8 bit register LOW
AH  (0b01_0000)   GP 8 bit register HIGH
BX  (0b00_0001)   GP 16 bit register
BL  (0b10_0001)   GP 8 bit register LOW
BH  (0b01_0001)   GP 8 bit register HIGH
CX  (0b00_0010)   GP 16 bit register
CL  (0b10_0010)   GP 8 bit register LOW
CH  (0b01_0010)   GP 8 bit register HIGH
DX  (0b00_0011)   GP 16 bit register
DL  (0b10_0011)   GP 8 bit register LOW
DH  (0b01_0011)   GP 8 bit register HIGH
ZX  (0b00_0100)   GP 16 bit register
ZL  (0b10_0100)   GP 8 bit register LOW
ZH  (0b01_0100)   GP 8 bit register HIGH
PC  (0b00_0101)   Program Counter   32 bit register
SP  (0b00_0110)   Stack Pointer     32 bit register
MB  (0b00_0111)   Memory bank       16 bit register
X   (0b00_1000)   16 bit Index register
XL  (0b10_1000)   8 bit Index register LOW
XH  (0b01_1000)   8 bit Index register HIGH
Y   (0b00_1001)   16 bit Index register
YL  (0b10_1001)   8 bit Index register LOW
YH  (0b01_1001)   8 bit Index register HIGH
EAX (0b11_1010)   GP 32 bit register            (2 16 bit registers EAL and EAH)
EBX (0b11_1011)   GP 32 bit register            (2 16 bit registers EBL and EBH)
F   (0b00_1111)
    0x0000  LESS
    0x0001  EQUAL
    0x0002  ZERO
    0x0004  CARRY
    0x0008  INT ENABLE
    0x0010  HALT
    0x0020  SIGN FLAG
    0x0040  PARITY FLAG
    0x0080  UNUSED
    0x0100  UNUSED
    0x0200  UNUSED
    0x0400  UNUSED
    0x0800  UNUSED
    0x1000  UNUSED
    0x2000  UNUSED
    0x4000  UNUSED
    0x8000  UNUSED

register Low and High
all the registers can be split in to a high and an low part 

Calling convention
    Arguments pushed to stack in order from right to left
    Registers pushed if used in func
    Return value in Z
    After return offset the SP with the length of the arguments using add

INSTRUCTIONS LAYOUT
XXXX_XXXX_1111_ZZZZ
X 8 bit instructions identifier
Z 4 bit instructions argument identifier

ARGUMENT IDENTIFIER
0000    imm
0001    addr
0010    register
0011    Indexed
0101    20 bit enable addr

1000    32 bit imm

MEMORY LAYOUT
0x00000  -   0x0FFFF: GENERAL PURPOSE ROM
0x10000  -   0x101FF: IO
0x10200  -   0x10FFF: STACK
0x11000  -   0x11FFF: contains
0x12000  -   0x13FFF: GENERAL PURPOSE RAM
0x14000  -   0x16FFF: GENERAL PURPOSE RAM (BANKED)
0x17000  -   0x1FFF9: GENERAL PURPOSE RAM
0x1FFFA  -   0x1FFFA: UNUSED
0x1FFFB  -   0x1FFFB: UNUSED
0x1FFFC  -   0x1FFFC: UNUSED
0x1FFFD  -   0x1FFFD: UNUSED
0x1FFFE  -   0x1FFFE: Exit code
0x1FFFF  -   0x1FFFF: define addr

0x14000 - 0x16FFF can be swapped using the MB register, 
if MB = 0 indicates that the built-in RAM is in use.
if MB = 1 indicates that the RAM 

PORTS
PORTS are used to communicate with devices or by the BES-8 itself. See
SPECIAL PORTS for a list of which ports are controlled by the BES-8 and not
external devices.

SPECIAL PORTS
0x000: 
0x001: SCREEN
0x002: User Port1
0x003: User Port2
0x004: User Port3
0x005: User Port4
0x006 - 0x00F: 6 Expansion port 
0x010: Disk Header
0x011 - 0x01F: 14 Disk slots (more in the FileSystemSPEC.txt)

EXPANSION PORT
in the Expansion port there is a way to expant the memory using the data bus and addr bus.
you cna ues the inb and outb to communicate to a device on the 10 Expansion port,
this can be a mouse, a Keyboard and other things for example extar RAM.

SCREEN
The screen circuit can be read/written to using INB and OUTB instructions.
It contains 5 registers that can be read/written for the curosrs and other things, 
The screen is 192 x 144 pixles and the screen buffer is on bord, with a 128 color palette.
the screen can be in to different modes depending on the starting value sent to register 1

