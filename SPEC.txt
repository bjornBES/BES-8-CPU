OVERVIEW
 16 bit data width
 20 bit addr width ~ 131 kilobytes
 Memory banking via the MB register allowing for 65535 possible memory banks
 
INSTRUCTIONS
 00 MOV     reg/addr,           reg/imm/addr    -> reg/mem[addr] = reg/imm/mem[addr]
 01 
 02 
 03 PUSH    reg16/imm16                         -> mem[SP] = reg16/imm16 SP--
 04 POP     reg16/addr                          -> SP++ reg16/addr = mem[SP]
 05 ADD     reg16,              reg16/imm       -> reg16 = reg16 + reg16/imm16 + C
 06 
 07 SUB     reg16,              reg16/imm       -> reg16 = reg16 - reg16/imm16 - C
 08 AND     reg16,              reg16/imm       -> reg16 = reg16 & reg16/imm16
 09 OR      reg16,              reg16/imm       -> reg16 = reg16 | reg16/imm16
 0A NOR     reg16,              reg16/imm       -> reg16 = !(reg16 | reg16/imm16)
 0B CMP     reg16,              reg16/imm       -> F = reg16 - imm/reg16
 0C JNE     addr                                -> PC = addr if E == 0
 0D INT                                         -> system call 
 0E JMP     addr                                -> PC = addr
 0F JME     addr                                -> PC = addr if E == 1
 10 HALT    imm16/null                          -> DIS
 11 CALL    addr                                -> push PC, PC = addr
 12 RTS                                         -> pop PC
 13 INC     reg16/addr                          -> reg16/mem[addr]++
 14 DEC     reg16/addr                          -> reg16/mem[addr]--
 15 OUTB    imm16/reg16           reg16/imm16   -> port[imm16/reg16] = reg16/imm16
 16 INB     imm16/reg16           reg16         -> reg = port[imm16/reg16]
 17 NOP                                         -> 
 18 SEF     imm16                               -> F[imm16] = 1
 19 CLF     imm16                               -> F[imm16] = 0
 1A JMZ     addr                                -> PC = addr if Z == 1
 1B JNZ     addr                                -> PC = addr if Z == 0
 1C JML     addr                                -> PC = addr if L == 1
 1D JMG     addr                                -> PC = addr if L == 0
 1E JMC     addr                                -> PC = addr if C == 1
 1F JNC     addr                                -> PC = addr if C == 0
 20 MUL     reg16,              reg16/imm16     -> reg16 = reg16 * reg16/imm16
 21 DIV     reg16,              reg16/imm16     -> reg16 = reg16 / reg16/imm16
 22 NOT     reg16                               -> reg16 = !reg16 
 23 ADDL    reg32,              reg32/imm32     -> reg32 = reg32 + reg32/imm32 + C
 24 SUBL    reg32               reg32/imm32     -> reg32 = reg32 - reg32/imm32 - C
 25 ANDL    reg32               reg32/imm32     -> reg32 = reg32 & reg32/imm32 
 26 ORL     reg32               reg32/imm32     -> reg32 = reg32 | reg32/imm32
 27 NORL    reg32               reg32/imm32     -> reg32 = !(reg32 | reg32/imm32)
 28 NOTL    reg32                               -> reg32 = !reg32
 29 JMPL    reg32/addr                          -> PC = reg32/addr
 30 PUSHL   imm32/reg32                         -> mem[SP] = reg32[H]/imm32[H] SP-- mem[SP] = reg32[L]/imm32[L] SP--
 31 POPL    reg32                               -> SP++ reg32 = mem[SP] + mem[SP + 1] SP++
 32 PUSHR                                       -> push AX push BX push CX push DX push ZX push X push Y
 33 POPR                                        -> pop Y pop X pop ZX pop DX pop CX pop BX pop AX
 34 ROL     reg16               imm16/null      -> reg16 << imm16 if null 1
 35 ROR     reg16               imm16/null      -> reg16 >> imm16 if null 1
 36 JER     addr                                -> PC = addr if ER = 1

REGISTERS
AX  (0b00_0000)   GP 16 bit register
AL  (0b10_0000)   GP 8 bit register LOW
AH  (0b01_0000)   GP 8 bit register HIGH
BX  (0b00_0001)   GP 16 bit register
BL  (0b10_0001)   GP 8 bit register LOW
BH  (0b01_0001)   GP 8 bit register HIGH
CX  (0b00_0010)   GP 16 bit register
CL  (0b10_0010)   GP 8 bit register LOW
CH  (0b01_0010)   GP 8 bit register HIGH
DX  (0b00_0011)   GP 16 bit register
DL  (0b10_0011)   GP 8 bit register LOW
DH  (0b01_0011)   GP 8 bit register HIGH
ZX  (0b00_0100)   GP 16 bit register
ZL  (0b10_0100)   GP 8 bit register LOW
ZH  (0b01_0100)   GP 8 bit register HIGH
PC  (0b00_0101)   Program Counter   32 bit register
SP  (0b00_0110)   Stack Pointer     32 bit register
MB  (0b00_0111)   Memory bank       16 bit register
X   (0b00_1000)   16 bit Index register
XL  (0b10_1000)   8 bit Index register LOW
XH  (0b01_1000)   8 bit Index register HIGH
Y   (0b00_1001)   16 bit Index register
YL  (0b10_1001)   8 bit Index register LOW
YH  (0b01_1001)   8 bit Index register HIGH
EAX (0b11_1010)   GP 32 bit register            (2 16 bit registers EAL and EAH)
EBX (0b11_1011)   GP 32 bit register            (2 16 bit registers EBL and EBH)
F   (0b00_1111)
    0x0000  LESS        0
    0x0001  EQUAL       1
    0x0002  ZERO        2
    0x0004  CARRY       3
    0x0008  INT ENABLE  4
    0x0010  HALT        5
    0x0020  SIGN FLAG   6
    0x0040  PARITY FLAG 7
    0x0080  UNUSED      8
    0x0100  UNUSED      9
    0x0200  UNUSED      10
    0x0400  UNUSED      11
    0x0800  UNUSED      12
    0x1000  UNUSED      13
    0x2000  UNUSED      14
    0x4000  UNUSED      15
    0x8000  ERROR FLAG  16

register Low and High
all the registers can be split in to a high and an low part 

Calling convention
    Arguments pushed to stack in order from right to left
    Registers pushed if used in func
    Return value in Z
    After return offset the SP with the length of the arguments using add

INSTRUCTIONS LAYOUT
XXXX_XXXX_ZZZZ_ZZZZ_1111
X 8 bit instructions identifier
Z 8 bit instructions argument identifier

ARGUMENT IDENTIFIER
0000    imm
0001    addr
0010    register
0011    Indexed with register
0100    Indexed with addr

1000    32 bit imm

MEMORY LAYOUT
0x00000 - 0x2FFFF: GENERAL PURPOSE ROM
0x30000 - 0x301FF: IO
0x30200 - 0x30FFF: STACK
0x31000 - 0x31FFF: contains
0x32000 - 0x36FFF: GENERAL PURPOSE RAM (BANKED)
0x37000 - 0x3700F: Program Buffer
0x37010 - 0xFFFF9: GENERAL PURPOSE RAM
0xFFFFA - 0xFFFFA: UNUSED
0xFFFFB - 0xFFFFB: UNUSED
0xFFFFC - 0xFFFFC: UNUSED
0xFFFFD - 0xFFFFD: UNUSED
0xFFFFE - 0xFFFFE: Exit code
0xFFFFF - 0xFFFFF: define addr

0x32000 - 0x36FFF can be swapped using the MB register, 
if MB = 0 indicates that the built-in RAM is in use.
if MB = 1 indicates that the RAM 

PORTS
PORTS are used to communicate with devices or by the BES-8 itself. See
SPECIAL PORTS for a list of which ports are controlled by the BES-8 and not
external devices.

SPECIAL PORTS
0x000: 
0x001: SCREEN
0x002: User Port1
0x003: User Port2
0x004: User Port3
0x005: User Port4
0x006 - 0x00F: 6 Expansion port 
0x010: Disk Header
0x011 - 0x01F: 14 Disk slots (more in the FileSystemSPEC.txt)

EXPANSION PORT
in the Expansion port there is a way to expant the memory using the data bus and addr bus.
you cna ues the inb and outb to communicate to a device on the 10 Expansion port,
this can be a mouse, a Keyboard and other things for example extar RAM.

SCREEN
The screen circuit can be read/written to using INB and OUTB instructions.
It contains 5 registers that can be read/written for the curosrs and other things, 
The screen is 192 x 144 pixles and the screen buffer is on bord, with a 128 color palette.
the screen can be in to different modes depending on the starting value sent to register 1

Micro Instructions

LAYOUT
00_00_0000_0000_00000000
0E LH RRRR AAAA IIIIIIII

E = register enable
L = low enable
H = high enable
R = register identifier
I = instruction identifier
A = argument identifier

Instructions
00_00_0000_0_00 (00010)
register disbaled
argument imm
instr MOV (Mov_Reg_16)

01_00_0101_F_50 (45F50)
register PC
argument implied
instr inc (inc_Reg_32)

01_00_0101_F_80 (45F80)
register PC
argument implied
instr out_Reg_32

00_00_0000_0_FF (000FF)
instr End instruction

00_00_0000_F_EF (00FEF)
instr 

00_00_0000_0_31 (00031)
Set_Addr_Ram

00_00_0000_0_01 (00001)
Write_Ram

00_00_0000_0_61 (00061) Outb Imm
Ports_Data_Out

00_00_0000_2_61 (00261)  Outb Reg
Ports_Data_Out

00_00_0000_0_71 (00071) Inb imm
Ports_Data_Out  

00_00_0000_2_71 (00271)  Outb Reg
Ports_Data_Out  